#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""annotators.py: Contains gene annotators for TCGA data."""

from pathlib import Path
from typing import Callable, List
from .tcga import TCGA
import mbf_genomics
from mbf_genomics.annotator import Annotator
import pandas as pd
import pypipegraph as ppg

__author__ = "Marco Mernberger"
__copyright__ = "Copyright (c) 2020 Marco Mernberger"
__license__ = "mit"


class HtseqFromTCGA(Annotator):
    def __init__(
        self,
        name: str,
        tcga: TCGA,
        sample_selector: Callable,
        fill: float = 0,
        dependencies: ppg.Job = [],
        data_type: str = "counts",
    ):
        """
        Annotates the HTseq counts and FPKM data obtained from TCGA datasets.

        This depends on tcga.write_htseq_counts_df() bein executed so that
        the counts data is already present. As this annotator infers the
        column to add from the dataframe generated by the tcga object,
        column names are not nown upon declaration, only during pypipegraph
        execution.

        Parameters
        ----------
        name : str
            Name of the annotator, gets appended to the column names.
        tcga : TCGA
            the tcga data object, from which the data was drawn.
        sample_selector : Callable
            A function that returns the column names during pypipegraph
            execution.
        fill : float, optional
            Fill missing values that may arise during dataframe joins, by
            default 0.
        dependencies : ppg.Job, optional
            List of jobs this job depends on, by default [].
        data_type : str, optional
            The datatype to collect, either counts or FPKM, by default "counts".
        """
        self.name = f"{name} {data_type}({tcga.name})"
        self.tcga = tcga
        self._columns: List[str] = []
        self.datatype = data_type
        self.sample_selector = sample_selector
        self.dependencies = dependencies
        self.dependencies.extend(
            [
                ppg.FunctionInvariant(
                    f"{self.name}_sample_selector", self.sample_selector
                ),
                tcga.write_htseq_meta(),
                tcga.write_htseq_counts_df(),
            ]
        )
        self.cache_dir = Path("cache") / "HtseqFromTCGA" / self.name
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        if self.datatype == "counts":
            fileno = 0
        else:
            fileno = 1
        self.table_path = self.tcga.write_htseq_counts_df().filenames[fileno]

    def __repr__(self):
        return self.name

    def __str__(self):
        return self.name

    def get_cache_name(self):
        return f"cache_{self.name}".replace(" ", "_")

    @property
    def columns(self):
        return self._columns

    @columns.setter
    def columns(self, value):
        self._columns = value

    def load_columns(self):
        """
        Returns a load job that ensures that the annotator columns are present.

        Any downstream annotation job must depend on this.
        """

        def __get_columns():
            samples = self.sample_selector()
            columns = [f"{self.name} {c}(htseq {self.datatype})" for c in samples]
            if len(columns) == 0:
                raise ValueError(f"The annotator {self.name} does not add any columns.")
            return columns

        return ppg.CachedAttributeLoadingJob(
                str(self.cache_dir / f"{self.name}_columns"),
                self,
                "columns",
                __get_columns,
            ).depends_on(self.dependencies)

    def calc_ddf(self, ddf: mbf_genomics.DelayedDataFrame) -> ppg.Job:
        """
        Function that actually creates the DataFrame to be attached to the
        DelayedDataFrame given.

        Parameters
        ----------
        ddf : mbf_genomics.DelayedDataFrame
            The DelayedDataFrame to be annotated.

        Returns
        -------
        New DataFrame to be appended to the ddf.
        """
        df = ddf.df.copy()
        df["index"] = df.index
        df_in = pd.read_csv(self.table_path, sep="\t")
        renamed = dict(
            [
                (
                    x.replace(f"(htseq {self.datatype})", "").replace(
                        self.name + " ", ""
                    ),
                    x,
                )
                for x in self.columns
            ]
        )
        df_in = df_in.rename(columns=renamed)
        # Ensure the fields are joined to the correct genes, index by stable_id
        df_out = df.set_index("gene_stable_id").join(
            df_in.set_index("gene_stable_id"), how="left"
        )
        df_out["gene_stable_id"] = df_out.index
        df_out = df_out.set_index("index")
        df_out = df_out[self.columns]
        df_out = df_out.fillna(0)
        if self.datatype == "counts":
            df_out = df_out.astype(int)
        assert len(df_out) == len(df)
        return df_out

    def deps(self, ddf):
        """Return ppg.jobs"""
        return self.dependencies + [self.load_columns()]


class HtseqFromTCGA_CPM(HtseqFromTCGA):
    def __init__(
        self,
        name: str,
        tcga: TCGA,
        sample_selector: Callable,
        fill: float = 0,
        dependencies: ppg.Job = [],
        data_type: str = "counts",
    ):
        super().__init__(name, tcga, sample_selector, fill, dependencies, data_type)
        self.name = f"{name} {data_type} (CPM)({tcga.name})"
        self.normalize_to = 1e6

    def calc_ddf(self, ddf: mbf_genomics.DelayedDataFrame) -> ppg.Job:
        """
        Function that actually creates the DataFrame to be attached to the
        DelayedDataFrame given.

        Parameters
        ----------
        ddf : mbf_genomics.DelayedDataFrame
            The DelayedDataFrame to be annotated.

        Returns
        -------
        New DataFrame to be appended to the ddf.
        """
        df = ddf.df.copy()
        df["index"] = df.index
        df_in = pd.read_csv(self.table_path, sep="\t")
        renamed = dict(
            [
                (
                    x.replace(f"(htseq {self.datatype})", "").replace(
                        self.name + " ", ""
                    ),
                    x,
                )
                for x in self.columns
            ]
        )
        df_in = df_in.rename(columns=renamed)
        # Ensure the fields are joined to the correct genes, index by stable_id
        df_out = df.set_index("gene_stable_id").join(
            df_in.set_index("gene_stable_id"), how="left"
        )
        df_out["gene_stable_id"] = df_out.index
        df_out = df_out.set_index("index")
        df_out = df_out[self.columns]
        df_out = df_out.fillna(0)
        for col in self.columns:
            raw_counts = df[col]
            total = max(1, float(raw_counts.sum()))  # avoid division by 0
            result = raw_counts * (self.normalize_to / total)
            df[col] = result
        df_out = df_out.astype(int)
        assert len(df_out) == len(df)
        return df_out
